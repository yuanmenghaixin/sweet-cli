[{"size":1386,"name":"README.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/README.md","content":"<h1 id=\"sweet-ui-\">Sweet UI 开发文档</h1>\n<h2 id=\"-\">介绍</h2>\n<p>Sweet UI 2.0 版本开始，结合前端模块化，工程化开发的思想，对框架结构进行了划分，主要划分为以下几个模块</p>\n<p><strong>1. Sweet Loader</strong></p>\n<p>Sweet UI 前端开发工程脚手架</p>\n<p><a href=\"https://github.com/sweetui/sweet-loader\">仓库地址：https://github.com/sweetui/sweet-loader</a></p>\n<p><strong>2. Sweet Core</strong></p>\n<p>Sweet UI 框架核心功能，框架运作的核心代码，并提供丰富的框架工具</p>\n<p><a href=\"https://github.com/sweetui/sweet\">仓库地址：https://github.com/sweetui/sweet</a></p>\n<p><strong>3. Sweet Style</strong></p>\n<p>Sweet 默认样式，符合Sweet UI 视觉规范的默认样式</p>\n<p><a href=\"https://github.com/sweetui/sweet-style\">仓库地址：https://github.com/sweetui/sweet-style</a></p>\n<p><strong>4. Sweet Cli （设计中）</strong></p>\n<p>Sweet UI 命令行工具，可用来快速搭建和配置前端工程</p>\n<p><a href=\"https://github.com/sweetui/sweet-cli\">仓库地址：https://github.com/sweetui/sweet-cli</a></p>\n<h2 id=\"sweet-ui-loader\">Sweet UI Loader</h2>\n<ul>\n<li>开始<ul>\n<li><a href=\"loader/start.md\">安装和启动</a></li>\n<li><a href=\"loader/norms.md\">开发规范</a></li>\n<li><a href=\"loader/directory.md\">目录结构</a></li>\n</ul>\n</li>\n<li>架构<ul>\n<li>架构总览</li>\n<li>入口文件</li>\n<li>模块设计</li>\n<li>模块加载</li>\n<li>样式加载</li>\n</ul>\n</li>\n<li>配置<ul>\n<li>环境配置</li>\n<li>反向代理设置</li>\n</ul>\n</li>\n<li>路由</li>\n<li>部署<ul>\n<li>生产部署</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sweet-core\">Sweet Core</h2>\n<ul>\n<li>VUEX</li>\n<li>国际化</li>\n<li><a href=\"sweet-core/axios.md\">Axios(AJAX)</a></li>\n</ul>\n<h2 id=\"sweet-style\">Sweet Style</h2>\n<ul>\n<li>主题样式</li>\n<li>弹性盒子模型</li>\n</ul>\n"},{"name":"loader","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/loader","children":[{"size":1049,"name":"directory.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/loader/directory.md","content":"<h1 id=\"-\">目录结构</h1>\n<h2 id=\"-\">一级目录结构</h2>\n<pre><code>├── .babelrc                // babel配置文件\n├── .editorconfig           // 编辑器配置文件\n├── .eslintignore           // eslint过滤规则配置文件\n├── .eslintrc.js            // eslint校验规则配置文件\n├── .gitignore              // git过滤规则配置文件\n├── CHANGELOG.md            // 更新日志\n├── LICENSE                 // 协议文件\n├── README.md\n├── build                   // 编译脚本\n├── config                  // 环境配置文件目录\n├── dist                    // 打包编译输出目录\n├── gulpfile.js             // gulp配置文件\n├── package-lock.json       // npm 模块安装锁定版本配置文件\n├── package.json\n├── src                     // 开发资源目录\n└── yarn.lock               // yarn 模块安装锁定版本配置文件\n</code></pre><blockquote>\n<p>对于框架使用者来说，只需要关注 <code>config</code> 和 <code>src</code> 这两个文件夹里面的内容</p>\n</blockquote>\n"},{"size":15,"name":"directory_structure.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/loader/directory_structure.md","content":"<h1 id=\"-\">目录结构</h1>\n"},{"size":1706,"name":"norms.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/loader/norms.md","content":"<h1 id=\"-\">开发规范</h1>\n<h2 id=\"-\">命名规范</h2>\n<ol>\n<li><p>目录和文件</p>\n</li>\n<li><p>目录使用小写+下划线；</p>\n</li>\n<li>文件采用驼峰发驼峰法（首字母小写），例如 userList.vue；</li>\n</ol>\n<ol>\n<li><p>函数和类、属性命名</p>\n</li>\n<li><p>class类和构造函数的命名采用驼峰法（首字母大写），例如 User、UserType；</p>\n</li>\n<li>方法的命名使用驼峰法（首字母小写），例如 getUserName；</li>\n<li><p>属性的命名使用驼峰法（首字母小写），例如 tableName、instance；</p>\n</li>\n<li><p>常量和配置</p>\n</li>\n<li><p>常量和环境变量定义，以大写字母和下划线命名，例如 APP_PATH；</p>\n</li>\n</ol>\n<h2 id=\"-\">代码规范</h2>\n<blockquote>\n<p>为了保证代码的一致性和避免错误，同时提升团队协作时，代码的可读性和可维护性。框架引入了 ESLint 作为代码风格检查工具。\n当有报错或者警告时，大家可以通过 <a href=\"http://eslint.cn/\">http://eslint.cn/</a> 输入相应的错误代码进行查询</p>\n</blockquote>\n<h3 id=\"-eslint-\">编辑器安装\bESLint工具</h3>\n<p>在开发时，为了更方便的\b获取提醒，甚至自动修正。推荐大家在各自使用的编辑器上安装<code>ESLint</code>的相关插件</p>\n<p><strong>1. 全局安装 ESLint</strong></p>\n<p>无论使用何种编辑器，推荐都进行全局安装 ESLint</p>\n<pre><code>// windows\nnpm i eslint -g\n\n// mac/linux\nsudo npm i eslint -g\n</code></pre><p><strong>2. VSCode</strong></p>\n<p>a. 搜索 <code>ESLint</code> 扩展，并安装</p>\n<p>b. 左下角齿轮点开，进入<code>设置</code>界面</p>\n<p>c. 在右侧\b，\b添加以下配置</p>\n<pre><code>&quot;eslint.validate&quot;: [\n    &quot;javascript&quot;,\n    &quot;javascriptreact&quot;,\n    {\n        &quot;language&quot;: &quot;html&quot;,\n        &quot;autoFix&quot;: true\n    },\n    {\n        &quot;language&quot;: &quot;vue&quot;,\n        &quot;autoFix&quot;: true\n    }\n]\n</code></pre><p><strong>3. Sublime</strong></p>\n<p>\b安装 <code>ESLint</code>，<code>SublimeLinter</code> 和 <code>SublimeLinter-contrib-eslint</code> 这三个插件即可</p>\n<p><strong>其他编辑器正在整理中……</strong></p>\n"},{"size":519,"name":"start.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/loader/start.md","content":"<h1 id=\"-\">安装和启动</h1>\n<h2 id=\"1-python2-7\">1. 安装Python2.7</h2>\n<p>由于框架中推荐使用scss，需要依赖Python2.7 的版本，因此在安装工程环境之前，需要先安装好Python2.7，并配置好系统环境变量。</p>\n<p><strong>【注意】要求安装是Python2.7版本，不是Python3.x版本</strong></p>\n<p>安装配置Python教程：  <a href=\"http://blog.csdn.net/u011781521/article/details/53909151\">http://blog.csdn.net/u011781521/article/details/53909151</a></p>\n<p>也可以自行网上搜索相关的资料</p>\n<h2 id=\"2-npm-\">2. 使用npm 官方源安装</h2>\n<pre><code>npm install\n</code></pre><h2 id=\"3-\">3. 前端开发工程启动</h2>\n<pre><code>npm start\n</code></pre>"}]},{"size":14403,"name":"npm使用说明.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/npm使用说明.md","content":"<h1 id=\"npm-\">npm 仓库使用说明</h1>\n<blockquote>\n<p>私库npm包下载地址：<a href=\"http://10.200.45.216:8081/repository/npm-all/\">http://10.200.45.216:8081/repository/npm-all/</a>\n私库npm包发布地址：<a href=\"http://10.200.45.216:8081/repository/npm-geely/\">http://10.200.45.216:8081/repository/npm-geely/</a></p>\n</blockquote>\n<h2 id=\"-\">权限管理</h2>\n<p>npm允许通过<code>scope</code>组织私有包，通过<code>team</code>细化权限控制。</p>\n<p>npm官方仓储有两种类型的包，普通包和scope包</p>\n<p>普通包特征:</p>\n<ul>\n<li>只能公有，谁都可以下载使用</li>\n<li>仅可以通过所有者(owner)进行权限控制，如果要允许某个用户修改或发布包，必须将该用户添加到包的所有者列表。添加到包所有者列表的用户具备所有的权限.</li>\n</ul>\n<p>scope包特征:</p>\n<ul>\n<li>包名有两部组成，@scope/name, @后的为scope名,/后的才是具体的包名</li>\n<li>可以控制公有和私有</li>\n<li>细化的权限控制，比如可以创建团队,并赋予团队对包只读/修改的权限</li>\n</ul>\n<h3 id=\"owner\">owner</h3>\n<pre><code>\nnpm owner add &lt;user&gt; [&lt;@scope&gt;/]&lt;pkg&gt; # 将用户添加到包的所有者列表\nnpm owner rm &lt;user&gt; [&lt;@scope&gt;/]&lt;pkg&gt; # 从包的所有这列表中删除用户\nnpm owner ls [&lt;@scope&gt;/]&lt;pkg&gt; # 列出包的所有者\n</code></pre><p>成为包的所有者的用户，将能够修改元数据(如标记弃用)，发布新版本,添加其他用户到包的所有者列表</p>\n<h3 id=\"t-team\">t/team</h3>\n<pre><code>\nnpm team create &lt;scope:team&gt; # 创建团队\nnpm team destroy &lt;scope:team&gt; # 删除团队\n\nnpm team add &lt;scope:team&gt; &lt;user&gt; # 添加用户到团队\nnpm team rm &lt;scope:team&gt; &lt;user&gt; # 从团队中移除用户\n\nnpm team ls &lt;scope&gt;|&lt;scope:team&gt; 列出团队/成员\n\nnpm team edit &lt;scope:team&gt;  用编辑器编辑团队信息\n</code></pre><h3 id=\"access\">access</h3>\n<pre><code>\nnpm access public [&lt;package&gt;]  # 设置包开放\nnpm access restricted [&lt;package&gt;] # 设置包私有\n\nnpm access grant &lt;read-only|read-write&gt; &lt;scope:team&gt; [&lt;package&gt;] # 设置团队对包可以只读/允许修改\nnpm access revoke &lt;scope:team&gt; [&lt;package&gt;] # 从团队中收回包权限\n\nnpm access ls-packages [&lt;user&gt;|&lt;scope&gt;|&lt;scope:team&gt;]  # 列出用户/域/团队能够访问的包\nnpm access ls-collaborators [&lt;package&gt; [&lt;user&gt;]] # 列出包的权限信息\nnpm access edit [&lt;package&gt;] # 用编辑器编辑包权限\n</code></pre><h3 id=\"adduser-login\">adduser/login</h3>\n<pre><code>npm adduser [--registry=url] [--scope=@orgname] [--always-auth]\n</code></pre><p>提示输入username, password, email，进行登录校验，返回token保存到.npmrc</p>\n<h3 id=\"logout\">logout</h3>\n<pre><code>npm logout [--registry=&lt;url&gt;] [--scope=&lt;@scope&gt;]\n</code></pre><p>请求仓储服务将当前token失效</p>\n<h3 id=\"whoami\">whoami</h3>\n<pre><code>npm whoami [--registry &lt;registry&gt;]\n</code></pre><p>列出用户在npmjs.org上的用户名</p>\n<h2 id=\"-\">仓储</h2>\n<h3 id=\"s-se-search\">s/se/search</h3>\n<pre><code>npm search [-l|--long] [--json] [--parseable] [--no-description] [search terms ...]\n-l|--long: 展示出全部的DESCRIPTION栏信息\n--no-description: 不显示DESCRIPTION栏信息\n</code></pre><h3 id=\"publish\">publish</h3>\n<pre><code>npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;]\n--tag: 带上tag信息发布,之后包可以通过npm install &lt;name&gt;@&lt;tag&gt;安装\n--access: 仅适用于scope包,默认为restricted\n</code></pre><h3 id=\"unpublish\">unpublish</h3>\n<pre><code>npm unpublish [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]\n</code></pre><p>从仓储中删除包,该操作会破坏依赖，不推荐适用，如果是为了鼓励用户适用新版本，可以使用deprecate命令</p>\n<h3 id=\"deprecate\">deprecate</h3>\n<pre><code>npm deprecate &lt;pkg&gt;[@&lt;version&gt;] &lt;message&gt;\n</code></pre><p>标记包弃用，用户在安装时npm会有警告</p>\n<h3 id=\"stars\">stars</h3>\n<pre><code>npm stars [&lt;user&gt;]\n</code></pre><p>查看用户喜欢的包</p>\n<h3 id=\"star-unstart\">star/unstart</h3>\n<pre><code>npm star [&lt;pkg&gt;...]\nnpm unstar [&lt;pkg&gt;...]\n</code></pre><p>标记喜欢/取消喜欢标记</p>\n<h2 id=\"-\">本地</h2>\n<h3 id=\"init\">init</h3>\n<pre><code>npm init [-f|--force|-y|--yes]\n</code></pre><p>初始化package.json, 默认会有很多输入提示，可以通过-f|--force|-y|--yes选项创建默认配置的package.json\n已经存在package.json后再次运行npm init不会破坏已有配置,只会变更你真正改动的部分</p>\n<h3 id=\"i-install\">i/install</h3>\n<pre><code>npm install (with no args, in package dir) # 读取package.json安装\nnpm install [&lt;@scope&gt;/]&lt;name&gt; # 默认安装标签为latest\nnpm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt; # 指定标签\nnpm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt; # 指定版本\nnpm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt; # 指定版本范围\nnpm install &lt;tarball file&gt;  # 通过tarball文件安装\nnpm install &lt;tarball url&gt; # 通过tarball文件url链接安装\nnpm install &lt;git remote url&gt; # 通过git安装包, url格式为&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt;]\nnpm install &lt;folder&gt; 通过包所在的文件夹安装\n</code></pre><ul>\n<li>--registry: 从指定仓储中下载安装包</li>\n<li>-S/--save: 安装并保存包信息到package.json的dependencies区</li>\n<li>-D/--save-dev: 安装并保存包信息到package.json的devDependencies区</li>\n<li>--tag: 优先根据标签而不是版本安装包</li>\n<li>--dry-run: 报告安装状况而不真的安装</li>\n<li>-f/--force: 安装时跳过缓存直接从远程下载</li>\n<li>-g/--global: 安装到全局</li>\n<li>--link: 链接全局安装的包的本地</li>\n<li>--no-shrinkwrap: 安装时忽略shrinkwrap</li>\n</ul>\n<h3 id=\"un-uninstall\">un/uninstall</h3>\n<pre><code>npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev]\n</code></pre><ul>\n<li>-S/--save: 删除包并移除包在package.json的dependencies区的信息</li>\n<li>-D/--save-dev: 删除包并移除包在package.json的devDependencies区的信息</li>\n</ul>\n<h3 id=\"ddp-dedupe\">ddp/dedupe</h3>\n<pre><code>npm dedupe\n</code></pre><p>npm检查包依赖树并清除不要的包</p>\n<h3 id=\"dist-tags\">dist-tags</h3>\n<pre><code>npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;] # 添加标签\nnpm dist-tag rm &lt;pkg&gt; &lt;tag&gt; # 移除标签\nnpm dist-tag ls [&lt;pkg&gt;] # 列出包所包含的标签\n</code></pre><p>常见标签有latest, next, lts等</p>\n<p>可以在发布和下载包是带上标签</p>\n<pre><code>npm publish # 默认标签latest\nnpm publish --tag next  # 发布next标签\nnpm install npm # 默认标签latest\nnpm install npm@next\nnpm install --tag next\n</code></pre><ul>\n<li>--registry: 发布包到指定仓储</li>\n</ul>\n<h3 id=\"v-version\">v/version</h3>\n<pre><code>npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]\n</code></pre><p>该命令执行步骤</p>\n<ol>\n<li>检查git工作目录</li>\n<li>运行preversion脚本, 可以写些触发测试的脚本</li>\n<li>结合当前包当前版本信息和patch, minor, major等，生成新版本号，更新package.json中version字段</li>\n<li>patch 1.0.0 =&gt; 1.0.1</li>\n<li>prepatch 1.0.0 =&gt; 1.0.1-0</li>\n<li>minor 1.0.0 =&gt; 1.1.0</li>\n<li>preminor 1.0.0 =&gt; 1.1.0-0</li>\n<li>major 1.0.0 =&gt; 2.0.0</li>\n<li>premajor 1.0.0 =&gt; 2.0.0-0</li>\n<li>prerelease 1.0.0-0 =&gt; 1.0.0-1</li>\n<li>from-git 从git获取版本信息</li>\n<li>运行version脚本</li>\n<li>git提交并打标签</li>\n<li>运行postversion脚本</li>\n</ol>\n<h3 id=\"it-install-test\">it/install-test</h3>\n<pre><code>npm it\nnpm install-test\n</code></pre><p>相当于运行npm install &amp;&amp; npm test</p>\n<h3 id=\"ln-link\">ln/link</h3>\n<pre><code>npm link  # 在全局node_modules下创建当前文件夹的超链接\nnpm link [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;] # 将全局安装的包链接到本地node_modules中\n</code></pre><h3 id=\"ls-list\">ls/list</h3>\n<pre><code>npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...]\n</code></pre><p>打印依赖树</p>\n<ul>\n<li>--json: 已json格式输出</li>\n<li>--long: 展示更多信息</li>\n<li>--parseable: 显示展平的目录而不是依赖树</li>\n<li>--global: 显示全局安装的包的依赖树</li>\n<li>--depth: 树层级,从0开始</li>\n<li>--prod/production: 仅显示package.json里dependencies包的依赖</li>\n<li>--dev: 仅显示package.json里devDependencies包的依赖</li>\n</ul>\n<h3 id=\"up-update\">up/update</h3>\n<pre><code>npm update [-g] [&lt;pkg&gt;...]\n</code></pre><p>更新包到包的semver所允许的最新版本, 并安装遗漏的包</p>\n<ul>\n<li>--save: 更新并保存更新到package.json</li>\n<li>--dev: 同时更新devDependencies中的包</li>\n<li>--depth: 默认情况下仅更新顶层(--depth=0)为0的包,如果想更新所有包，可以指定--depth=9999</li>\n</ul>\n<h3 id=\"outdated\">outdated</h3>\n<pre><code>npm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...]\n</code></pre><p>.e.g</p>\n<pre><code>Package        Current  Wanted  Latest  Location\najv              4.8.2  4.11.8   5.0.1  example\nasync            2.1.2   2.4.0   2.4.0  example\nbody-parser     1.15.2  1.17.1  1.17.1  example\n</code></pre><p>列表栏</p>\n<ul>\n<li>Current: 当前版本</li>\n<li>Wanted: smever允许的最高版本</li>\n<li>Latest: 仓储中最新版本</li>\n<li>Location: 依赖树中的位置</li>\n</ul>\n<p>命令选项</p>\n<ul>\n<li>--json: 已json格式输出</li>\n<li>--long: 展示更多信息</li>\n<li>--parseable: 平铺展示</li>\n<li>--global: 显示全局安装的包的依赖树</li>\n<li>--depth: 树层级,默认0</li>\n</ul>\n<h3 id=\"pack\">pack</h3>\n<pre><code>npm pack [[&lt;@scope&gt;/]&lt;pkg&gt;...]\n</code></pre><p>从包生成名为<name>-<version>.tgz的tarball,并缓存</p>\n<h3 id=\"prune\">prune</h3>\n<pre><code>npm prune [[&lt;@scope&gt;/]&lt;pkg&gt;...] [--production]\n</code></pre><p>清理不在package.json生成的依赖树中的包</p>\n<ul>\n<li>--production: 移除devDependencies中的包</li>\n</ul>\n<h3 id=\"shrinkwrap\">shrinkwrap</h3>\n<pre><code>npm shrinkwrap\n</code></pre><p>shrinkwrap用来锁定依赖包的版本</p>\n<p>包A的package.json</p>\n<pre><code>{\n    &quot;name&quot;: &quot;A&quot;,\n    &quot;version&quot;: &quot;0.1.0&quot;,\n    &quot;dependencies&quot;: {\n        &quot;B&quot;: &quot;&lt;0.1.0&quot;\n    }\n}\n</code></pre><p>包A的依赖树</p>\n<pre><code> A@0.1.0\n    `-- B@0.0.1\n        `-- C@0.0.1\n</code></pre><p>当B有新版本0.0.2发布, B@0.0.2满足&lt;0.1.0, 所以npm install A安装成功后依赖树</p>\n<pre><code> A@0.1.0\n    `-- B@0.0.2\n        `-- C@0.0.1\n</code></pre><p>我们希望包A依赖的B版本保持在B@0.0.1, 可以运行</p>\n<h3 id=\"npm-shrinkwrap\">npm shrinkwrap</h3>\n<p>该命令会生成npm-shrinkwrap.json, 其内容如下</p>\n<pre><code>{\n  &quot;name&quot;: &quot;A&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;dependencies&quot;: {\n    &quot;B&quot;: {\n      &quot;version&quot;: &quot;0.0.1&quot;,\n      &quot;from&quot;: &quot;B@^0.0.1&quot;,\n      &quot;resolved&quot;: &quot;https://registry.npmjs.org/B/-/B-0.0.1.tgz&quot;,\n      &quot;dependencies&quot;: {\n        &quot;C&quot;: {\n          &quot;version&quot;: &quot;0.0.1&quot;,\n          &quot;from&quot;: &quot;org/C#v0.0.1&quot;,\n          &quot;resolved&quot;: &quot;git://github.com/org/C.git#5c380ae319fc4efe9e7f2d9c78b0faa588fd99b4&quot;\n        }\n      }\n    }\n  }\n}\n</code></pre><p>运行<code>npm install</code>时如果存在npm-shrinkwrap.json, npm在安装包时会根据shrinkwrap.json锁定依赖包的版本</p>\n<h3 id=\"cache\">cache</h3>\n<pre><code>npm cache add &lt;tarball file&gt; # 添加到缓存\nnpm cache add &lt;folder&gt;\nnpm cache add &lt;tarball url&gt;\nnpm cache add &lt;name&gt;@&lt;version&gt;\n\nnpm cache ls [&lt;path&gt;]  # 缓存明细\n\nnpm cache clean [&lt;path&gt;] # 清除缓存\n</code></pre><p>缓存路径可以通过npm config get cache获取</p>\n<h2 id=\"-\">脚本</h2>\n<p>package.json的scripts区可以用来定义自定义脚本</p>\n<h3 id=\"run-run-script\">run/run-script</h3>\n<pre><code>npm run &lt;command&gt; [-- &lt;args&gt;...]\n</code></pre><p>运行package.json的scripts中定义的命令</p>\n<p>npm run会自动将<code>node_modules/.bin</code>添加到环境变量PATH中。如果本地安装过mocha, 可以这样编写<code>&quot;scripts&quot;: {&quot;test&quot;: &quot;mocha test/\\*.js&quot;}</code>而不需要<code>&quot;scripts&quot;: {&quot;test&quot;: &quot;node_modules/.bin/tap test/\\*.js&quot;}</code></p>\n<h3 id=\"start\">start</h3>\n<pre><code>npm start [-- &lt;args&gt;]\n</code></pre><p>等同与npm run start [-- <args>]</p>\n<h3 id=\"stop\">stop</h3>\n<pre><code>npm stop [-- &lt;args&gt;]\n</code></pre><p>等同与npm run stop [-- <args>]</p>\n<h3 id=\"tst-test\">tst/test</h3>\n<pre><code>npm test [-- &lt;args&gt;]\n</code></pre><p>等同与npm run test [-- <args>]</p>\n<h3 id=\"rb-rebuild\">rb/rebuild</h3>\n<pre><code>npm rebuild [[&lt;@scope&gt;/&lt;name&gt;]...]\n</code></pre><p>运行指定包中的build脚本,适用于更新node版本后，重新编译C++包</p>\n<p>restart</p>\n<pre><code>npm restart [-- &lt;args&gt;]\n</code></pre><p>循序执行1. prerestart 2. prestop 3. stop 4. poststop 5. restart 6. prestart 7. start 8. poststart 9. postrestart</p>\n<h2 id=\"-\">配置</h2>\n<h3 id=\"c-config\">c/config</h3>\n<pre><code>npm config set &lt;key&gt; &lt;value&gt; [-g|--global] # 添加或更新\nnpm config get &lt;key&gt; # 获取\nnpm config delete &lt;key&gt; # 删除\nnpm config list #  配置明细\nnpm config edit # 编辑器编辑\n</code></pre><ul>\n<li>--global: 全局配置</li>\n</ul>\n<h3 id=\"get\">get</h3>\n<pre><code>npm get &lt;key&gt; # 同npm config get\n</code></pre><h3 id=\"set\">set</h3>\n<pre><code>npm set &lt;key&gt; &lt;value&gt; [-g|--global] #同npm config set\n</code></pre><h2 id=\"-\">查看</h2>\n<h3 id=\"root\">root</h3>\n<pre><code>npm root # 打印本地node_modules目录\nnpm root -g # 打印全局node_modules目录\n</code></pre><h3 id=\"prefix\">prefix</h3>\n<pre><code>npm prefix # 打印包含package.json最近父目录\nnpm prefix -g # 打印全局配置prefix的值\n</code></pre><h3 id=\"view\">view</h3>\n<pre><code>npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]\n</code></pre><p>查看仓储信息</p>\n<pre><code>npm view compact\n\n\n#  打印\n{ name: &#39;compact&#39;,\n  description: &#39;A JavaScript compacting middleware for express&#39;,\n  &#39;dist-tags&#39;: { latest: &#39;0.1.2&#39; },\n  maintainers: [ &#39;serby &lt;paul@serby.net&gt;&#39; ],\n  time:\n   { modified: &#39;2017-03-28T12:49:48.000Z&#39;,\n     created: &#39;2012-02-06T01:39:50.261Z&#39;,\n     &#39;0.1.2&#39;: &#39;2012-09-04T11:19:17.618Z&#39;,\n     &#39;0.1.1&#39;: &#39;2012-08-29T08:18:12.345Z&#39;,\n     &#39;0.1.0&#39;: &#39;2012-07-09T14:40:56.751Z&#39;,\n     &#39;0.0.7&#39;: &#39;2012-07-04T17:14:01.593Z&#39;,\n     &#39;0.0.6&#39;: &#39;2012-06-29T14:29:04.847Z&#39;,\n     &#39;0.0.5&#39;: &#39;2012-05-23T10:10:15.010Z&#39;,\n     &#39;0.0.4&#39;: &#39;2012-03-31T09:05:40.450Z&#39;,\n     &#39;0.0.3&#39;: &#39;2012-03-23T15:25:18.289Z&#39;,\n     &#39;0.0.2&#39;: &#39;2012-03-21T18:15:24.718Z&#39;,\n     &#39;0.0.1&#39;: &#39;2012-02-06T01:39:50.261Z&#39; },\n  users: { serby: true },\n  author: &#39;Paul Serby &lt;paul@serby.net&gt;&#39;,\n  repository: { type: &#39;git&#39;, url: &#39;git://github.com/serby/compact.git&#39; },\n  versions:\n   [ &#39;0.0.1&#39;,\n     &#39;0.0.2&#39;,\n     &#39;0.0.3&#39;,\n     &#39;0.0.4&#39;,\n     &#39;0.0.5&#39;,\n     &#39;0.0.6&#39;,\n     &#39;0.0.7&#39;,\n     &#39;0.1.0&#39;,\n     &#39;0.1.1&#39;,\n     &#39;0.1.2&#39; ],\n  version: &#39;0.1.2&#39;,\n  main: &#39;./lib/compact.js&#39;,\n  scripts: { test: &#39;mocha -r should -R spec&#39; },\n  engines: { node: &#39;&gt;=0.8&#39; },\n  dependencies:\n   { lodash: &#39;~0.3&#39;,\n     async: &#39;~0.1&#39;,\n     &#39;uglify-js&#39;: &#39;~1.3&#39;,\n     mkdirp: &#39;~0.3&#39; },\n  devDependencies: { mocha: &#39;*&#39;, should: &#39;~1.1&#39;, async: &#39;~0.1&#39;, asyncjs: &#39;~0.0&#39; },\n  optionalDependencies: {},\n  dist:\n   { shasum: &#39;66361e17108185bf261d42aff6a91b925e473139&#39;,\n     size: 7603,\n     noattachment: false,\n     tarball: &#39;http://registry.npm.taobao.org/compact/download/compact-0.1.2.tgz&#39; },\n  directories: {},\n  publish_time: 1346757557618 }\n</code></pre><p>npm view compact@0.1.2 dependencies</p>\n<pre><code># 打印\n{ lodash: &#39;~0.3&#39;,\n  async: &#39;~0.1&#39;,\n  &#39;uglify-js&#39;: &#39;~1.3&#39;,\n  mkdirp: &#39;~0.3&#39; }\n</code></pre><h3 id=\"bin\">bin</h3>\n<pre><code>npm bin # 打印包含npm bin目录, 通常为node_modules/.bin/\nnpm prefix -g # 打印全局npm bin目录\n</code></pre><h3 id=\"bugs-issue\">bugs/issue</h3>\n<pre><code>npm bugs [&lt;packagename&gt;]\n</code></pre><p>打开包bug追踪url</p>\n<pre><code>npm bugs npm # 浏览器打开https://github.com/npm/npm/issues\n</code></pre><h3 id=\"docs-home\">docs/home</h3>\n<pre><code>npm docs [&lt;pkgname&gt; [&lt;pkgname&gt; ...]]\nnpm docs .\nnpm home [&lt;pkgname&gt; [&lt;pkgname&gt; ...]]\nnpm home .\n</code></pre><p>打开文档url</p>\n<pre><code>npm docs npm #浏览器打开https://docs.npmjs.com/\n</code></pre><h3 id=\"repo\">repo</h3>\n<pre><code>npm repo [&lt;pkg&gt;]\n</code></pre><p>打开git url</p>\n<pre><code>npm repo npm #浏览器打开https://github.com/npm/npm\n</code></pre><h3 id=\"help\">help</h3>\n<pre><code>npm help &lt;term&gt; [&lt;terms..&gt;]\n</code></pre><p>打印特定术语或命令的帮助</p>\n<h3 id=\"help-search\">help-search</h3>\n<pre><code>npm help-search &lt;text&gt;\n</code></pre><p>从npm官方markdown文档中搜索词条</p>\n<h2 id=\"-\">其他</h2>\n<h3 id=\"completion\">completion</h3>\n<pre><code>npm completion &gt;&gt; ~/.bashrc\n</code></pre><p>npm命令插补脚本</p>\n<h3 id=\"doctor\">doctor</h3>\n<pre><code>npm doctor\n</code></pre><p>环境检测</p>\n<ul>\n<li>npm能调用node和git命令</li>\n<li>registry能够访问</li>\n<li>本地和全局node_modules可写</li>\n<li>缓存存在且tarball文件健全</li>\n</ul>\n<h3 id=\"edit\">edit</h3>\n<pre><code>npm edit &lt;pkg&gt;[@&lt;version&gt;]\n</code></pre><p>进入包目录并启动编辑器</p>\n<h3 id=\"explore\">explore</h3>\n<pre><code>npm explore &lt;pkg&gt; [-- &lt;cmd&gt;]\n</code></pre><p>进入包目录并运行命令</p>\n<pre><code>npm explore connect -- ls\n\n# 打印\nHISTORY.md  index.js  LICENSE  node_modules  package.json  README.md\n</code></pre><h3 id=\"ping\">ping</h3>\n<pre><code>npm ping [--registry &lt;registry&gt;]\nnpm ping --registry https://registry.npmjs.org\n</code></pre><p>检查仓储是否可用</p>\n"},{"name":"sweet-core","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/sweet-core","children":[{"size":1821,"name":"axios.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/sweet-core/axios.md","content":"<h1 id=\"axios\">AXIOS</h1>\n<blockquote>\n<p>Sweet UI 2.0 版本开始 AJAX 全部采用 axios</p>\n</blockquote>\n<h2 id=\"-\">特色</h2>\n<ul>\n<li>浏览器端发起 XMLHttpRequests 请求</li>\n<li>node 端发起 http 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和返回</li>\n<li>转化请求和返回（数据）</li>\n<li>取消请求</li>\n<li>自动转化 json 数据</li>\n<li>客户端支持抵御<a href=\"https://baike.baidu.com/item/CSRF/2735433?fr=aladdin\">XSRF（跨站请求伪造）</a></li>\n</ul>\n<h2 id=\"-axios\">了解 Axios</h2>\n<p><a href=\"https://segmentfault.com/a/1190000008470355#articleHeader5\">中文文档</a>\n<a href=\"https://github.com/axios/axios\">官方文档</a></p>\n<h2 id=\"sweet-ui-\">Sweet UI 中的使用</h2>\n<h3 id=\"-\">全局配置</h3>\n<h3 id=\"get\">GET</h3>\n<pre><code>// 在组件内或者vuex 内使用\nthis.SWXHR.GET(url,{\n    // 将要请求的参数包在 params 对象中\n    params: {\n        userName: &#39;name1&#39;,\n        id: &#39;1&#39;\n    }\n})\n.then(res =&gt; {\n    // res是收到的数据\n    console.log(res);\n})\n</code></pre><h3 id=\"post\">POST</h3>\n<pre><code>// 在组件内或者vuex 内使用\nthis.SWXHR.POST(url,{\n    // 和GET不一样，这里参数 不需要 包在 params 对象里面\n    userName: &#39;name1&#39;,\n    id: &#39;1&#39;\n})\n.then(res =&gt; {\n    // res是收到的数据\n    console.log(res);\n})\n</code></pre><h3 id=\"put\">PUT</h3>\n<pre><code>// 在组件内或者vuex 内使用\nthis.SWXHR.PUT(url,{\n    userName: &#39;name1&#39;,\n    id: &#39;1&#39;\n})\n.then(res =&gt; {\n    // res是收到的数据\n    console.log(res);\n})\n</code></pre><h3 id=\"delete\">DELETE</h3>\n<pre><code>// 在组件内或者vuex 内使用\nthis.SWXHR.DELETE(url, params: {\n    id: &#39;11&#39;\n  })\n.then(res =&gt; {\n    // res是收到的数据\n    console.log(res);\n})\n</code></pre><h2 id=\"-application-x-www-form-urlencoded-\">使用 application/x-www-form-urlencoded 格式化</h2>\n<p>默认情况下，axios 串联 js 对象为 JSON 格式。为了发送 application/x-wwww-form-urlencoded 格式数据，你可以使用一下的设置。</p>\n<p>使用 <code>qs</code> 库</p>\n<pre><code>var qs = require(&#39;qs&#39;);\nthis.SWXHR.POST(url, qs.stringify({&#39;bar&#39;:123}))\n.then(res =&gt; {\n    // res是收到的数据\n    console.log(res);\n})\n</code></pre>"}]},{"size":2166,"name":"模块发布流程.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/模块发布流程.md","content":"<h1 id=\"sweet-ui-2-0-\">Sweet UI 2.0 模块发布使用流程</h1>\n<h2 id=\"-\">一、打包要求</h2>\n<p>每个模块包里，都必须含有以下文件</p>\n<ol>\n<li><p>package.json</p>\n<p> 可以通过 <code>npm init</code> 来创建</p>\n<pre><code> // 最基本的格式\n {\n   &quot;name&quot;: &quot;module-name&quot;,    // 模块名\n   &quot;version&quot;: &quot;0.0.1&quot;,        // 版本号\n   &quot;description&quot;: &quot;npm test module&quot;,        // 模块简单描述，建议120字以内\n   &quot;main&quot;: &quot;index.js&quot;,        // 模块主入口文件\n   &quot;author&quot;: &quot;author name&quot;        // 开发者\n }\n</code></pre></li>\n<li><p>README.md</p>\n<p> readme 包含模块用途，功能描述，开发API等等说明</p>\n</li>\n</ol>\n<h2 id=\"-\">二、模块发布</h2>\n<ol>\n<li><p>将代码发布到git仓库</p>\n</li>\n<li><p>通过 Jenkins 自动化发布到 Nexus 仓库</p>\n</li>\n</ol>\n<h2 id=\"-\">三、模块使用</h2>\n<h3 id=\"-nrm\">安装 nrm</h3>\n<p>用于快速切换 <code>npm</code> 源（<code>registry</code>）</p>\n<ol>\n<li><p>安装</p>\n<pre><code> // windows\n npm i -g nrm\n\n // mac/linux\n sudo npm i -g nrm\n</code></pre></li>\n<li><p>查询</p>\n<p> 列出可选的源</p>\n<pre><code> nrm ls\n\n * npm ---- https://registry.npmjs.org/\n   cnpm --- http://r.cnpmjs.org/\n   taobao - http://registry.npm.taobao.org/\n   nj ----- https://registry.nodejitsu.com/\n   rednpm - http://registry.mirror.cqupt.edu.cn/\n   npmMirror  https://skimdb.npmjs.com/registry/\n   edunpm - http://registry.enpmjs.org/\n   geely -- http://10.200.45.216:4873/\n   nexus -- http://10.200.45.216:8081/repository/npm-all/\n</code></pre><p> 带 <code>*</code> 的是当前使用的源，上面的输出表明当前源是官方源。</p>\n</li>\n</ol>\n<ol>\n<li><p>切换</p>\n<p> 切换到taobao</p>\n<pre><code> nrm use taobao\n\n     Registry has been set to: http://registry.npm.taobao.org/\n</code></pre></li>\n<li><p>增加源</p>\n<p> 可以增加定制的源，特别适用于添加企业内部的私有源</p>\n<pre><code> nrm add  &lt;registry&gt; &lt;url&gt; [home]\n</code></pre></li>\n<li><p>删除源</p>\n<pre><code> nrm del &lt;registry&gt;\n</code></pre></li>\n<li><p>测试速度</p>\n<p> 还可以通过 <code>nrm test</code> 测试相应源的响应时间。</p>\n<pre><code> nrm test npm\n\n   npm ---- 1328ms\n</code></pre><p> 测试所有源的响应时间：</p>\n<pre><code> nrm test\n\n   npm ---- 891ms\n   cnpm --- 1213ms\n * taobao - 460ms\n   eu ----- 3859ms\n   au ----- 1073ms\n   sl ----- 4150ms\n   nj ----- 8008ms\n</code></pre></li>\n</ol>\n<h3 id=\"-\">安装模块</h3>\n<ol>\n<li><p>添加公司npm私库</p>\n<pre><code> nrm add nexus http://10.200.188.161:8081/repository/npm-all/\n</code></pre></li>\n<li><p>切换到公司npm私库</p>\n<pre><code> nrm use nexus\n</code></pre></li>\n<li><p>使用 <code>npm install</code> 安装模块</p>\n</li>\n</ol>\n"},{"size":1597,"name":"模块命名规范.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/模块命名规范.md","content":"<h1 id=\"sweet-ui-2-0-\">Sweet UI 2.0 模块命名规范</h1>\n<blockquote>\n<p>Sweet UI 将全部使用模块化开发。\n为了能让各种模块得到更好的复用，同时大家互相协作，互不影响干扰，在此提出了一些对模块命名进行规范。</p>\n</blockquote>\n<h2 id=\"-\">一、模块分类</h2>\n<ol>\n<li>组件模块</li>\n<li>业务模块</li>\n<li>纯主题样式模块</li>\n</ol>\n<h2 id=\"-src-plugins-\">二、组件（src/plugins）</h2>\n<h3 id=\"sweet-\">Sweet组件</h3>\n<p>命名规则：<strong>sweet-plugin-[PluginName]</strong></p>\n<p>例如：<strong>sweet-plugin-dropdown</strong></p>\n<h3 id=\"-\">项目组件</h3>\n<p>命名规则：<strong>[ProjectName]-plugin-[PluginName]</strong></p>\n<p>例如：<strong>SCRM-plugin-popover</strong></p>\n<h3 id=\"-js-\">第三方JS组件</h3>\n<p>鼓励直接通过 <code>npm install [pluginName] --save</code> 来安装第三方组件，然后通过 <code>import</code> 或者 <code>require</code> 来引入第三方组件。\n当有部分组件未提交到npm仓库时，可以采用以下命名规范进行引入。</p>\n<p>命名规则：<strong>sweet-vendor-[PluginName]</strong></p>\n<p>例如：<strong>sweet-vendor-layer</strong></p>\n<h2 id=\"-src-modules-\">三、业务模块（src/modules）</h2>\n<h3 id=\"sweet-\">Sweet平台公共业务模块</h3>\n<p>命名规则：<strong>sweet-module-[ModuleName]</strong></p>\n<p>例如：<strong>sweet-module-login</strong></p>\n<h3 id=\"-\">项目业务模块</h3>\n<p>命名规则：<strong>[ProjectName]-module-[ModuleName]</strong></p>\n<p>例如：<strong>SCRM-module-sale</strong></p>\n<h2 id=\"-src-styles-\">四、纯主题样式模块（src/styles）</h2>\n<p>样式模块只包含Sweet框架样式以及项目公共样式\n业务模块样式以及组件模块（包括第三方组件）的样式，建议放在各自的模块里面，直接引入</p>\n<h3 id=\"sweet-\">Sweet 样式</h3>\n<p>命名规则：<strong>sweet-style-[StyleName]</strong></p>\n<p>例如：<strong>sweet-style-default</strong></p>\n<h3 id=\"-\">项目公共样式</h3>\n<p>命名规则：<strong>[ProjectName]-style-[StyleName]</strong></p>\n<p>例如：<strong>SCRM-module-base</strong></p>\n"},{"size":2025,"name":"环境搭建及启动.md","path":"/Users/huyingjun/EVUN_WORK/sweet-cli/download/环境搭建及启动.md","content":"<h1 id=\"-\">环境搭建及启动</h1>\n<h2 id=\"-nodejs-\">安装 NodeJS 最新版本</h2>\n<p>NodeJS 下载地址: <a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<h2 id=\"-npm-nrm-\">安装npm源管理工具 <code>nrm</code></h2>\n<p>用于快速切换 <code>npm</code> 源（<code>registry</code>）</p>\n<ol>\n<li><p>安装</p>\n<pre><code> // windows\n npm i -g nrm\n\n // mac/linux\n sudo npm i -g nrm\n</code></pre></li>\n<li><p>查询</p>\n<p> 列出可选的源</p>\n<pre><code> nrm ls\n\n * npm ---- https://registry.npmjs.org/\n   cnpm --- http://r.cnpmjs.org/\n   taobao - http://registry.npm.taobao.org/\n   nj ----- https://registry.nodejitsu.com/\n   rednpm - http://registry.mirror.cqupt.edu.cn/\n   npmMirror  https://skimdb.npmjs.com/registry/\n   edunpm - http://registry.enpmjs.org/\n   geely -- http://10.200.45.216:4873/\n   nexus -- http://10.200.45.216:8081/repository/npm-all/\n</code></pre><p> 带 <code>*</code> 的是当前使用的源，上面的输出表明当前源是官方源。</p>\n</li>\n</ol>\n<ol>\n<li><p>切换</p>\n<p> 切换到taobao</p>\n<pre><code> nrm use taobao\n\n     Registry has been set to: http://registry.npm.taobao.org/\n</code></pre></li>\n<li><p>增加源</p>\n<p> 可以增加定制的源，特别适用于添加企业内部的私有源</p>\n<pre><code> nrm add  &lt;registry&gt; &lt;url&gt; [home]\n</code></pre></li>\n<li><p>删除源</p>\n<pre><code> nrm del &lt;registry&gt;\n</code></pre></li>\n<li><p>测试速度</p>\n<p> 还可以通过 <code>nrm test</code> 测试相应源的响应时间。</p>\n<pre><code> nrm test npm\n\n   npm ---- 1328ms\n</code></pre><p> 测试所有源的响应时间：</p>\n<pre><code> nrm test\n\n   npm ---- 891ms\n   cnpm --- 1213ms\n * taobao - 460ms\n   eu ----- 3859ms\n   au ----- 1073ms\n   sl ----- 4150ms\n   nj ----- 8008ms\n</code></pre></li>\n</ol>\n<h2 id=\"-\">安装环境所需要的工具</h2>\n<p>sweet框架一些核心工具为了方便大家引用，放到了公司npm私库上，因此需要通过公司npm私库进行安装</p>\n<ol>\n<li><p>添加公司npm私库</p>\n<pre><code> nrm add nexus http://10.200.188.161:8081/repository/npm-all/\n</code></pre></li>\n<li><p>切换到公司npm私库</p>\n<pre><code> nrm use nexus\n</code></pre></li>\n<li><p>使用 <code>npm install</code> 安装模块</p>\n</li>\n</ol>\n<h2 id=\"-\">启动</h2>\n<ol>\n<li><p>执行启动命令</p>\n<pre><code> npm start\n</code></pre></li>\n</ol>\n"}]